% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}


%
\documentclass[
  10pt,
  a4paperpaper,
  oneside,
  openany,
  final]{}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[left=2.245cm,right=2.245cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[normalem]{ulem}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Standardized Type Ordering}
\author{true \and true}
\date{2022-10-29}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{}
\tableofcontents
}
<h1 data-number="1" id="abstract"><span class="header-section-number">1</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>Currently, <code class="sourceCode default">std::type_info</code>
provides a stable but <em>implementation defined</em> order of types.
Despite being unchangeable at runtime, the implementation defined
<code class="sourceCode default">type_info::before</code> is not marked
<code class="sourceCode default">constexpr</code>. This paper explores a
standardized ordering of types in C++, as well as the impact of marking
<code class="sourceCode default">type_info::before</code> constexpr.</p>
<h1 data-number="2" id="revision-history"><span class="header-section-number">2</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<p>New Paper</p>
<h1 data-number="3" id="motivation"><span class="header-section-number">3</span> Motivation<a href="#motivation" class="self-link"></a></h1>
<p>There is currently no way in C++ to sort types. Well-performing
typesets, required by various policy-based template libraries, require
constexpr evaluation of order.</p>
<p>This presents unsolvable problems for libraries that provide types
whose behavior is configured using a set (not a list) of policies.</p>
<p>The inability to sort these policies into a canonical order results
in different types with the same behavior.</p>
<p>Strong ordering of types also allows typesets to produce the same
symbol in different compilation units.</p>
<h1 data-number="4" id="proposal"><span class="header-section-number">4</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<p>#TODO Mention ordering of meta::info</p>
<h2 data-number="4.1" id="ordering-of-types"><span class="header-section-number">4.1</span> Ordering of Types<a href="#ordering-of-types" class="self-link"></a></h2>
<p>We propose the following as a canonical way of sorting all types that
are generated by the compiler. This order shall be available for
constexpr evaluation. This proposal does not encompass type successors
(i.e. <code class="sourceCode default">typeid(int).next()</code>),
defining only a comparison on two known types. (i.e. <code class="sourceCode default">typeid(int).before(typeid(char)))</code>)</p>
<h3 data-number="4.1.1" id="ordering-qualified-types"><span class="header-section-number">4.1.1</span> Ordering Qualified Types<a href="#ordering-qualified-types" class="self-link"></a></h3>
<p>For any unqualified type T, its qualified versions are ordered
immediately after it (preceding any other type or its own qualified
versions) in the following manner:</p>
<p>Qualifiers are each assigned a score</p>
<blockquote>
<p>&amp;: 1 &amp;&amp;: 2 const: 3 volatile: 6</p>
</blockquote>
<p>and ordering lowest-first after summing them.</p>
<p>For any unqualified type <code class="sourceCode default">T</code>,
the order of all possible qualified types would be:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span>  T</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>  T <span class="op">&amp;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span>  T <span class="op">&amp;&amp;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span>  T <span class="kw">const</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span>  T <span class="kw">const</span> <span class="op">&amp;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span>  T <span class="kw">const</span> <span class="op">&amp;&amp;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span>  T <span class="kw">volatile</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">7</span>  T <span class="kw">volatile</span> <span class="op">&amp;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span>  T <span class="kw">volatile</span> <span class="op">&amp;&amp;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span>  T <span class="kw">const</span> <span class="kw">volatile</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span> T <span class="kw">const</span> <span class="kw">volatile</span> <span class="op">&amp;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span> T <span class="kw">const</span> <span class="kw">volatile</span> <span class="op">&amp;&amp;</span></span></code></pre></div>
<p>The remainder of the paper concerns itself only with unqualified
types.</p>
<h3 data-number="4.1.2" id="ordering-scalar-types"><span class="header-section-number">4.1.2</span> Ordering Scalar Types<a href="#ordering-scalar-types" class="self-link"></a></h3>
<p>We order scalar types before any compound types; built-in types
first, followed by class types.</p>
<p>built-in types with simple names must be ordered before any types
that reference other types.</p>
<p>In particular, scalar types should be ordered as follows:</p>
<ol type="1">
<li><code class="sourceCode default">void</code> comes first because
it’s not reifiable,</li>
<li><code class="sourceCode default">nullptr_t</code> as the first
monostate</li>
<li>(any other monostates, if we ever add them, sorted
alphabetically)</li>
<li><code class="sourceCode default">bool</code> as the first
bi-state</li>
<li>(any other bi-states, if we ever add them)</li>
<li>Raw-memory types (<code class="sourceCode default">char</code>,
<code class="sourceCode default">signed char</code>,
<code class="sourceCode default">unsigned char</code>, std::byte)</li>
<li>Integral types in order of size, signed before unsigned
(<code class="sourceCode default">short</code>,
<code class="sourceCode default">unsigned short</code>,
<code class="sourceCode default">int</code>,
<code class="sourceCode default">unsigned int</code>,
<code class="sourceCode default">long</code>,
<code class="sourceCode default">unsigned long</code>,
<code class="sourceCode default">long long</code>,
<code class="sourceCode default">unsigned long long</code>, followed by
any implementation-defined wider integral types like __int128_t etc.).
Intersperse any implementation-defined built-in integral types as needed
between the above.</li>
<li>Any remaining character types that are not type-aliases of any of
the above, including unicode, according to the following rules: smallest
first, unicode-specific variants after non-unicode variants.</li>
<li>Floating-point types, in order of size. In case of ties,
<code class="sourceCode default">float</code>,
<code class="sourceCode default">double</code> and
<code class="sourceCode default">long double</code> come before any
types from
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html.</li>
<li>Enumeration types, (internally ordered by rules for class type
ordering by name)</li>
<li>Function types (internally ordered by rules in section
[function-types])</li>
<li>Pointer types (internally ordered by their pointee-type)</li>
<li>Pointer-to-member types (internally ordered by pointee-type)</li>
</ol>
<p>Class types shall be ordered according to the rules below, see
[ordering-classes]</p>
<h3 data-number="4.1.3" id="kinds"><span class="header-section-number">4.1.3</span> Kinds<a href="#kinds" class="self-link"></a></h3>
<p>There are the following kinds in the grammar, and shall be ordered as
follows from lowest to highest.</p>
<ul>
<li>value</li>
<li>namespace</li>
<li>function</li>
<li>member_function</li>
<li>function_template</li>
<li>lambda_function</li>
<li>type</li>
<li>class_template</li>
<li>variable_template</li>
<li>alias_template</li>
</ul>
<h4 data-number="4.1.3.1" id="list-of-atoms"><span class="header-section-number">4.1.3.1</span> List of atoms<a href="#list-of-atoms" class="self-link"></a></h4>
<p>The following are atoms of ordering tuples. They shall be ordered
from lowest to highest.</p>
<ul>
<li>scalar types</li>
<li><ul>
<li>(pointer)</li>
</ul></li>
<li>[] (unknown bound array)</li>
<li>[n] (known bound array of size n)</li>
<li>kinds (see <a href="#kinds">kinds</a>)</li>
<li>name of class</li>
<li>… (variadic parameter)</li>
<li>rank{n} (maybe)</li>
</ul>
<h3 data-number="4.1.4" id="namespaces"><span class="header-section-number">4.1.4</span> namespaces<a href="#namespaces" class="self-link"></a></h3>
<p>Namespaces shall be ordered alphabetically by comparing namespace
names at the same rank (as if their names were tuples of those strings).
A namespace comes before any of its subnamespaces.</p>
<p>Given:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> outer1 <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> i;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> outer2 <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">namespace</span> inner1 <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> i;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">namespace</span> inner2 <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> i;</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The order of the three structs w/ type
<code class="sourceCode default">i</code> types shall be <code class="sourceCode default">outer1::i &lt; outer2::inner1::i &lt; outer2::inner2::i</code>.</p>
<h4 data-number="4.1.4.1" id="anonymous-namespace"><span class="header-section-number">4.1.4.1</span> anonymous namespace<a href="#anonymous-namespace" class="self-link"></a></h4>
<p>The anonymous namespace shall be ordered after its enclosing
namespace but before any named namespaces.</p>
<h3 data-number="4.1.5" id="orderingtuple-name-tbd"><span class="header-section-number">4.1.5</span> OrderingTuple (Name TBD)<a href="#orderingtuple-name-tbd" class="self-link"></a></h3>
<p>For the sake of clarity, we’re going to define a construct called the
<code class="sourceCode default">OrderingTuple</code>.</p>
<p>Types will be broken down into
<code class="sourceCode default">OrderingTuple</code>s. Each value in
the tuple will be a pair of Kind (see <a href="#kinds">Kinds</a>) +
type.</p>
<p>These <code class="sourceCode default">OrderingTuples</code> will be
ordered lexicographically.</p>
<p>Given</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> foo<span class="op">::</span>bar <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> i;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> baz <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> j;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code class="sourceCode default">foo::bar::i</code> produces <code class="sourceCode default">((namespace, foo), (namespace, bar), (type, i)}</code></p>
<p><code class="sourceCode default">baz::j</code> produces
<code class="sourceCode default">((namespace, baz), (type, j))</code></p>
<p>When compared, these yield</p>
<p><code class="sourceCode default">baz::j</code> &lt;
<code class="sourceCode default">foo::bar::i</code>, since
<code class="sourceCode default">namespace baz</code> precedes
<code class="sourceCode default">namespace foo</code></p>
<h3 data-number="4.1.6" id="ordering-array-types"><span class="header-section-number">4.1.6</span> Ordering Array Types<a href="#ordering-array-types" class="self-link"></a></h3>
<p>Array types shall be ordered after scalar types but before class
types.</p>
<p>Order arrays first internally by element type, then by rank, then by
rank bounds, lowest first. Arrays of unknown bounds come before arrays
of known bounds.</p>
<p>So the order of the following, for a given type T:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>T<span class="op">[]</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>T<span class="op">[</span><span class="dv">10</span><span class="op">]</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>T<span class="op">[</span><span class="dv">11</span><span class="op">]</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>T<span class="op">[][</span><span class="dv">2</span><span class="op">]</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>T<span class="op">[</span><span class="dv">10</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>T<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span></span></code></pre></div>
<p>shall be ordered <code class="sourceCode default">T[] &lt; T[10] &lt; T[11] &lt; T[][2] &lt; T[3][2] &lt; T[10][2]</code>,</p>
<p>defining <code class="sourceCode default">OrderingTuple</code>s
<code class="sourceCode default">((type, T), [])</code>
<code class="sourceCode default">((type, T), [10])</code>
<code class="sourceCode default">((type, T), [11])</code>
<code class="sourceCode default">((type, T), [], [2])</code>
<code class="sourceCode default">((type, T), [10], [3])</code>
<code class="sourceCode default">((type, T), [3], [2])</code></p>
<h3 data-number="4.1.7" id="ordering-compound-types"><span class="header-section-number">4.1.7</span> Ordering Compound Types:<a href="#ordering-compound-types" class="self-link"></a></h3>
<h3 data-number="4.1.8" id="ordering-class-types"><span class="header-section-number">4.1.8</span> Ordering Class Types<a href="#ordering-class-types" class="self-link"></a></h3>
<p>Class types can be defined as either a
<code class="sourceCode default">struct</code> or a
<code class="sourceCode default">class</code>. As far as ordering is
concerned, structs and classes should be treated the same.</p>
<p>Class types shall be greater than scalar types.</p>
<p>Since we cannot redeclare two types with the same name, class types
shall be ordered alphabetically.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Apple <span class="op">{}</span>;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Banana <span class="op">{}</span>;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Carrot <span class="op">{}</span>;</span></code></pre></div>
<p>Would be ordered as
<code class="sourceCode default">Apple &lt; Banana &lt; Carrot</code></p>
<p>As such, we define the ordering tuples:</p>
<p><code class="sourceCode default">(type, Apple)</code>
<code class="sourceCode default">(type, Banana)</code>
<code class="sourceCode default">(type, Carrot)</code></p>
<h1 data-number="5" id="non-type-template-parameters"><span class="header-section-number">5</span> Non Type Template Parameters<a href="#non-type-template-parameters" class="self-link"></a></h1>
<p>NTTPs are lexicographically ordered by their scalar subobjects.</p>
<h2 data-number="5.1" id="class-templates"><span class="header-section-number">5.1</span> Class Templates<a href="#class-templates" class="self-link"></a></h2>
<p>Lets start with the simple case. Class templates are ordered by: 1.
Class name, alphabetically 2. Template arguments, applied
lexicographically.</p>
<p>For example, given:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Apple;</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Banana;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Carrot;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>Apple<span class="op">&lt;</span>Banana, Carrot<span class="op">&gt;</span>;</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>Apple<span class="op">&lt;</span>Banana, Banana<span class="op">&gt;</span>;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>Apple<span class="op">&lt;</span>Carrot, Carrot<span class="op">&gt;</span>;</span></code></pre></div>
<p>would be ordered <code class="sourceCode default">Apple&lt;Banana, Banana&gt; &lt; Apple&lt;Banana, Carrot&gt; &lt; Apple&lt;Carrot, Carrot&gt;</code>.</p>
<p>We can represent this with tuples: <code class="sourceCode default">(class_template, Apple, Banana, Carrot)</code>
<code class="sourceCode default">(class_template, Apple, Banana, Banana)</code>
<code class="sourceCode default">(class_template, Apple, Carrot, Carrot)</code></p>
<h3 data-number="5.1.1" id="function-types"><span class="header-section-number">5.1.1</span> Function Types<a href="#function-types" class="self-link"></a></h3>
<p>Function types shall be ordered by</p>
<ol type="1">
<li>Return type</li>
<li>Parameters, lexicographically.</li>
</ol>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span>;</span></code></pre></div>
<p>This function can be represented by: <code class="sourceCode default">(function, (type, void), (type, int))</code></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span>, <span class="dt">double</span><span class="op">)</span></span></code></pre></div>
<p>We can represent these types with <code class="sourceCode default">(function, (type, void), (type, int))</code>
<code class="sourceCode default">(function, (type, void), (type, int), (type, double))</code></p>
<p>So, the type of <code class="sourceCode default">void foo(int)</code>
would precede the type of
<code class="sourceCode default">void foo(int, double)</code></p>
<h3 data-number="5.1.2" id="member-function-types"><span class="header-section-number">5.1.2</span> Member Function Types<a href="#member-function-types" class="self-link"></a></h3>
<p>Function types shall be ordered by</p>
<ol type="1">
<li>Return type</li>
<li>The type of the class it is a member of.</li>
<li>Parameters, lexicographically.</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Foo <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar<span class="op">(</span><span class="dt">int</span> i, <span class="dt">float</span> j<span class="op">)</span>;</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>Produces the following tuple representation <code class="sourceCode default">(member_function, (type, void), (type, Foo), (type, int), (type, float))</code></p>
<h3 data-number="5.1.3" id="variadic-function-types"><span class="header-section-number">5.1.3</span> Variadic Function Types<a href="#variadic-function-types" class="self-link"></a></h3>
<p>Variadic function shall be ordered in a similar way. In a variadic
function, the last argument is a variadic argument. A variadic argument
shall be ordered immediately after its underlying type.</p>
<p>Given:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>Foo<span class="op">)</span>;</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>Foo<span class="op">...)</span>;</span></code></pre></div>
<h3 data-number="5.1.4" id="function-template-types"><span class="header-section-number">5.1.4</span> Function Template Types<a href="#function-template-types" class="self-link"></a></h3>
<p>In this case, the type of
<code class="sourceCode default">void foo(Foo...)</code> is ordered
immediately after the type of
<code class="sourceCode default">void foo(Foo)</code>.</p>
<!-- ### Type Aliases TODO

Type aliases are not types, and we don't need to concern ourselves
with how we order them. 

They shall be ordered exactly the same as the type they are aliased to.

### Type Alias Templates

```cpp
template <typename T>
using Foo = SomeType<T>;
``` -->
<p>Foo shall be ordered exactly the same way as
<code class="sourceCode default">SomeType&lt;T&gt;</code></p>
<h2 data-number="5.2" id="lambda-types"><span class="header-section-number">5.2</span> Lambda Types<a href="#lambda-types" class="self-link"></a></h2>
<p>Lambda Types shall be ordered in the same manner as functions. Ties
are broken by the point of instantiation.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Banana <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">auto</span> i <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{}</span>; <span class="co">// 0th lambda instantiated in Banana</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Apple <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> i <span class="op">=</span> <span class="op">[](</span><span class="dt">float</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{}</span>; <span class="co">// 0th lambda instantiated in Apple</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> j <span class="op">=</span> <span class="op">[]()</span> <span class="op">-&gt;</span> std<span class="op">::</span>string <span class="op">{}</span>; <span class="co">// 1st lambda instantiated in Apple</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>≈</p>
<p>These would produce the following tuples: <code class="sourceCode default">((namespace Banana), (lambda, (type, void), (type, int), (value, 0))</code>
<code class="sourceCode default">((namespace Apple), (lambda, (type, int), (type, float), (value, 0))</code>
<code class="sourceCode default">((namespace Apple), (lambda, (type, std::string), (value, 0))</code></p>
<h2 data-number="5.3" id="parameter-packs"><span class="header-section-number">5.3</span> Parameter Packs<a href="#parameter-packs" class="self-link"></a></h2>
<p>Parameter are ordered as class templates.</p>
<p>Given:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Types<span class="op">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Tuple <span class="op">{}</span>;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo <span class="op">{}</span>;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bar <span class="op">{}</span>;</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;&gt;</span> t0;</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> t1;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span>Foo<span class="op">&gt;</span> t2;</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span>Bar<span class="op">&gt;</span> t3;</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span>Foo, Bar<span class="op">&gt;</span> t4;</span></code></pre></div>
<p>would be ordered:
<code class="sourceCode default">Tuple&lt;&gt;</code> &lt;
<code class="sourceCode default">Tuple&lt;int&gt;</code> &lt;
<code class="sourceCode default">Tuple&lt;Bar&gt;</code> &lt;
<code class="sourceCode default">Tuple&lt;Foo&gt;</code> &lt;
<code class="sourceCode default">Tuple&lt;Foo, Bar&gt;</code></p>
<h2 data-number="5.4" id="kinds-of-templates"><span class="header-section-number">5.4</span> Kinds of Templates<a href="#kinds-of-templates" class="self-link"></a></h2>
<p>Kinds of templates shall first be ordered by arity.</p>
<p>Given:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">class</span><span class="op">&gt;</span> <span class="kw">class</span> Template<span class="op">&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> two<span class="op">{}</span>;</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">class</span><span class="op">&gt;</span> <span class="kw">struct</span> one<span class="op">{}</span>;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">struct</span> zero<span class="op">{}</span>;</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>zero<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> value0;</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>one<span class="op">&lt;</span>zero<span class="op">&gt;</span> value1;</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>two<span class="op">&lt;</span>one<span class="op">&gt;</span> value2;</span></code></pre></div>
<p>These are represented by tuples: <code class="sourceCode default">(type, zero, (class_template, int))</code>
<code class="sourceCode default">(type, one, (class_template, (type, zero, (class_template, int))))</code>
<code class="sourceCode default">(type, two, (class_template, (type, one, (class_template, rank{1}))))</code></p>
<h1 data-number="6" id="acknowledgements"><span class="header-section-number">6</span> Acknowledgements<a href="#acknowledgements" class="self-link"></a></h1>
<p>Thanks to all of the following: - Davis Herring for his suggestions
on ordering non-type template parameters.</p>

\end{document}
