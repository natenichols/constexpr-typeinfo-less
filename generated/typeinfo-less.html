% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}


%
\documentclass[
  10pt,
  a4paperpaper,
  oneside,
  openany,
  final]{}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[left=2.245cm,right=2.245cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[normalem]{ulem}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Standardized Type Ordering}
\author{true \and true}
\date{2022-10-29}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{}
\tableofcontents
}
<h1 data-number="1" id="abstract"><span class="header-section-number">1</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>Currently, <code class="sourceCode default">std::type_info</code>
provides a stable but <em>implementation defined</em> order of types.
Despite being unchangeable at runtime, the implementation defined
<code class="sourceCode default">type_info::before</code> is not marked
<code class="sourceCode default">constexpr</code>. This paper explores a
standardized ordering of types in C++, as well as the impact of marking
<code class="sourceCode default">type_info::before</code> constexpr.</p>
<h1 data-number="2" id="revision-history"><span class="header-section-number">2</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<p>New Paper</p>
<h1 data-number="3" id="motivation"><span class="header-section-number">3</span> Motivation<a href="#motivation" class="self-link"></a></h1>
<p>There is currently no way in C++ to sort types. Well-performing
typesets, required by various policy-based template libraries, require
constexpr evaluation of order.</p>
<p>This presents unsolvable problems for libraries that provide types
whose behavior is configured using a set (not a list) of policies.</p>
<p>The inability to sort these policies into a canonical order results
in different types with the same behavior.</p>
<h1 data-number="4" id="proposal"><span class="header-section-number">4</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<h2 data-number="4.1" id="ordering-of-types"><span class="header-section-number">4.1</span> Ordering of Types<a href="#ordering-of-types" class="self-link"></a></h2>
<p>We propose the following as a canonical way of sorting all types that
are generated by the compiler. This order will be available for
constexpr evaluation. This proposal does not encompass type successors
(i.e. <code class="sourceCode default">typeid(int).next()</code>),
defining only a comparison on two known types. (i.e. <code class="sourceCode default">typeid(int).before(typeid(char)))</code>)</p>
<h3 data-number="4.1.1" id="ordering-qualified-types"><span class="header-section-number">4.1.1</span> Ordering Qualified Types<a href="#ordering-qualified-types" class="self-link"></a></h3>
<p>For any unqualified type T, its qualified versions are ordered
immediately after it (preceding any other type or its own qualified
versions) in the following manner:</p>
<p>Qualifiers are each assigned a score</p>
<blockquote>
<p>&amp;: 1 &amp;&amp;: 2 const: 3 volatile: 6</p>
</blockquote>
<p>and ordering lowest-first after summing them.</p>
<p>For any unqualified type <code class="sourceCode default">T</code>,
the order of all possible qualified types would be:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span>  T</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>  T <span class="op">&amp;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span>  T <span class="op">&amp;&amp;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span>  T <span class="kw">const</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span>  T <span class="kw">const</span> <span class="op">&amp;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span>  T <span class="kw">const</span> <span class="op">&amp;&amp;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span>  T <span class="kw">volatile</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">7</span>  T <span class="kw">volatile</span> <span class="op">&amp;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span>  T <span class="kw">volatile</span> <span class="op">&amp;&amp;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span>  T <span class="kw">const</span> <span class="kw">volatile</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span> T <span class="kw">const</span> <span class="kw">volatile</span> <span class="op">&amp;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span> T <span class="kw">const</span> <span class="kw">volatile</span> <span class="op">&amp;&amp;</span></span></code></pre></div>
<p>The remainder of the paper concerns itself only with unqualified
types.</p>
<h3 data-number="4.1.2" id="ordering-native-types"><span class="header-section-number">4.1.2</span> Ordering Native Types<a href="#ordering-native-types" class="self-link"></a></h3>
<p>We order scalar types before any compound types; bult-in types first,
followed by user-defined types.</p>
<p>built-in types with simple names must be ordered before any types
that reference other types.</p>
<p>In particular, scalar types should be ordered as follows:</p>
<ol type="1">
<li><code class="sourceCode default">void</code> comes first because
it’s not reifiable,</li>
<li><code class="sourceCode default">nullptr_t</code> as the first
monostate</li>
<li>(any other monostates, if we ever add them, sorted
alphabetically)</li>
<li><code class="sourceCode default">bool</code> as the first
bi-state</li>
<li>(any other bi-states, if we ever add them)</li>
<li>Raw-memory types (<code class="sourceCode default">char</code>,
<code class="sourceCode default">signed char</code>,
<code class="sourceCode default">unsigned char</code>, std::byte)</li>
<li>Integral types in order of size, signed before unsigned
(<code class="sourceCode default">short</code>,
<code class="sourceCode default">unsigned short</code>,
<code class="sourceCode default">int</code>,
<code class="sourceCode default">unsigned int</code>,
<code class="sourceCode default">long</code>,
<code class="sourceCode default">unsigned long</code>,
<code class="sourceCode default">long long</code>,
<code class="sourceCode default">unsigned long long</code>, followed by
any implementation-defined wider integral types like __int128_t etc.).
Intersperse any implementation-defined built-in integral types as needed
between the above.</li>
<li>Any remaining character types that are not type-aliases of any of
the above, including unicode, according to the following rules: smallest
first, unicode-specific variants after non-unicode variants.</li>
<li>Floating-point types, in order of size. In case of ties,
<code class="sourceCode default">float</code>,
<code class="sourceCode default">double</code> and
<code class="sourceCode default">long double</code> come before any
types from
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html.</li>
<li>Enumeration types, (internally ordered by rules for class type
ordering by name)</li>
<li>Function types (internally ordered by rules in section
[function-types])</li>
<li>Pointer types (internally ordered by their pointee-type)</li>
<li>Pointer-to-member types (internally ordered by pointee-type)</li>
</ol>
<h3 data-number="4.1.3" id="ordering-compound-types"><span class="header-section-number">4.1.3</span> Ordering Compound types:<a href="#ordering-compound-types" class="self-link"></a></h3>
<p>Array types will be ordered after scalar types but before class
types.</p>
<p>Order arrays first internally by element type, then by rank, then by
rank bounds, lowest first. Arrays of unknown bounds come before arrays
of known bounds.</p>
<p>So the order of the following, for a given type T:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>T<span class="op">[]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>T<span class="op">[</span><span class="dv">10</span><span class="op">]</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>T<span class="op">[</span><span class="dv">11</span><span class="op">]</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>T<span class="op">[][</span><span class="dv">2</span><span class="op">]</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>T<span class="op">[</span><span class="dv">10</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>T<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span></span></code></pre></div>
<p>would be ordered <code class="sourceCode default">T[] &lt; T[10] &lt; T[11] &lt; T[][2] &lt; T[3][2] &lt; T[10][2]</code></p>
<p>Class types will be ordered according to the rules below, see
[ordering-classes]</p>
<h3 data-number="4.1.4" id="namespaces"><span class="header-section-number">4.1.4</span> namespaces<a href="#namespaces" class="self-link"></a></h3>
<p>Namespaces will be ordered alphabetically by comparing namespace
names at the same rank (as if their names were tuples of those strings).
A namespace comes before any of its subnamespaces.</p>
<p>Given:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> outer1 <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> i;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> outer2 <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">namespace</span> inner1 <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> i;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">namespace</span> inner2 <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> i;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The order of the three structs w/ type
<code class="sourceCode default">i</code> types would be <code class="sourceCode default">outer1::i &lt; outer2::inner1::i &lt; outer2::inner2::i</code>.</p>
<h3 data-number="4.1.5" id="anonymous-namespace"><span class="header-section-number">4.1.5</span> anonymous namespace<a href="#anonymous-namespace" class="self-link"></a></h3>
<p>The anonymous namespace shall be ordered after its enclosing
namespace but before any named namespaces.</p>
<h3 data-number="4.1.6" id="class-types"><span class="header-section-number">4.1.6</span> Class Types<a href="#class-types" class="self-link"></a></h3>
<p>Class types can be defined as either a
<code class="sourceCode default">struct</code> or a
<code class="sourceCode default">class</code>. As far as ordering is
concerned, structs and classes should be treated the same.</p>
<p>Class types shall be greater than native types.</p>
<p>Ordering these is simple, since we cannot redeclare two types with
the same name, we’ll just order simple class types alphabetically.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Apple <span class="op">{}</span>;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Banana <span class="op">{}</span>;</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Carrot <span class="op">{}</span>;</span></code></pre></div>
<p>Would be ordered as
<code class="sourceCode default">Apple &lt; Banana &lt; Carrot</code></p>
<h1 data-number="5" id="value-ordering"><span class="header-section-number">5</span> Value Ordering<a href="#value-ordering" class="self-link"></a></h1>
<p>Values can be used to create template specializations. Take, for
example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">....</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>Foo<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;</span>;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>Foo<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;</span>;</span></code></pre></div>
<p>To account for this, we must define an order for values. Values shall
be ordered first by their types, then by their individual values.</p>
<p>so in the case of</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>Foo<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>Foo<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;</span></span></code></pre></div>
<p><code class="sourceCode default">Foo&lt;1&gt; &lt; Foo&lt;2&gt;</code></p>
<p>When ordering types with value template arguments,
<code class="sourceCode default">typeinfo</code> shall use the
<code class="sourceCode default">operator&lt;=&gt;</code></p>
<p>Values without
<code class="sourceCode default">operator&lt;=&gt;</code> cannot be
compared, and shall be considered ill-formed. An example of this would
be</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Foo <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i;</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Notice, no way to order two Foos</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> Foo<span class="op">(</span><span class="dt">int</span> i_<span class="op">)</span> <span class="op">:</span> i<span class="op">{</span>i_<span class="op">}</span> <span class="op">{}</span>;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">friend</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;(</span>Foo <span class="kw">const</span><span class="op">&amp;</span> lhs, Foo <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">=</span> <span class="kw">delete</span>;</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>Foo T<span class="op">&gt;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Bar <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j <span class="op">=</span> T<span class="op">.</span>i;</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<h2 data-number="5.1" id="class-templates"><span class="header-section-number">5.1</span> Class Templates<a href="#class-templates" class="self-link"></a></h2>
<p>Lets start with the simple case. Class templates are ordered by: 1.
Class name, alphabetically 2. Number of template arguments. 3. Order of
template arguments applied left to right.</p>
<p>For example, given:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Apple;</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Banana;</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Carrot;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>Apple<span class="op">&lt;</span>Banana, Carrot<span class="op">&gt;</span>;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>Apple<span class="op">&lt;</span>Banana, Banana<span class="op">&gt;</span>;</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>Apple<span class="op">&lt;</span>Carrot, Carrot<span class="op">&gt;</span>;</span></code></pre></div>
<p>would be ordered <code class="sourceCode default">Apple&lt;Banana, Banana&gt; &lt; Apple&lt;Banana, Carrot&gt; &lt; Apple&lt;Carrot, Carrot&gt;</code>.</p>
<h2 data-number="5.2" id="function-types"><span class="header-section-number">5.2</span> Function Types<a href="#function-types" class="self-link"></a></h2>
<p>Function types will be ordered by</p>
<ol type="1">
<li>Name (alphabetically)</li>
<li>Number of parameters</li>
<li>Order of parameters. Applied left to right and ordered as described
above.</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span>;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span>;</span></code></pre></div>
<p>First, order by name, so
<code class="sourceCode default">void bar(int) &lt; void foo(int)</code></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span>, <span class="dt">double</span><span class="op">)</span></span></code></pre></div>
<p>Next, order by number of parameters, so <code class="sourceCode default">void foo(int) &lt; void foo(int, double)</code></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Apple <span class="op">{}</span>;</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Banana <span class="op">{}</span>;</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>Apple<span class="op">)</span>;</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>Banana<span class="op">)</span>;</span></code></pre></div>
<p>Finally, order each parameter left to right as described above, so
<code class="sourceCode default">void foo(Apple) &lt; void foo(Banana)</code></p>
<p>Left to right meaning the order of the following:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Apple <span class="op">{}</span>;</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Banana <span class="op">{}</span>;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>Apple, Apple<span class="op">)</span>;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>Apple, Banana<span class="op">)</span>;</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>Banana, Apple<span class="op">)</span>;</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>Banana, Banana<span class="op">)</span>;</span></code></pre></div>
<p>Gives us the ordering <code class="sourceCode default">void foo(Apple, Apple) &lt; void foo(Apple, Banana) &lt; void foo(Banana, Apple) &lt; void foo(Banana, Banana)</code></p>
<h3 data-number="5.2.1" id="template-specializations"><span class="header-section-number">5.2.1</span> Template Specializations<a href="#template-specializations" class="self-link"></a></h3>
<p>Template specializations will be orded in the same way as class
templates. First by name, then by the length of the argument list,
compared as a tuple of arguments.</p>
<h3 data-number="5.2.2" id="variadic-function-types"><span class="header-section-number">5.2.2</span> Variadic Function Types<a href="#variadic-function-types" class="self-link"></a></h3>
<p>Variadic function shall be ordered in a similar way. In a variadic
function, the last argument is a variadic argument. A variadic argument
will be ordered after all possible qualified types of its underlying
type.</p>
<p>Given:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">float</span>, <span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span>, <span class="dt">float</span><span class="op">)</span>;</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">float</span>, <span class="dt">int</span><span class="op">...)</span>;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span>, <span class="dt">float</span><span class="op">...)</span>;</span></code></pre></div>
<p>According to [ordering-qualified-types], int is ordered before float,
so <code class="sourceCode default">foo(int) &lt; foo(int, float) &lt; foo(int, float...) &lt; foo(float, int) &lt; foo(float, int...)</code></p>
<h3 data-number="5.2.3" id="type-aliases"><span class="header-section-number">5.2.3</span> Type Aliases<a href="#type-aliases" class="self-link"></a></h3>
<p>Type aliases are not types, and we don’t need to concern ourselves
with how we order them.</p>
<p>They will be ordered exactly the same as the type they are aliased
to.</p>
<h3 data-number="5.2.4" id="type-alias-templates"><span class="header-section-number">5.2.4</span> Type Alias Templates<a href="#type-alias-templates" class="self-link"></a></h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Foo <span class="op">=</span> SomeType<span class="op">&lt;</span>T<span class="op">&gt;</span>;</span></code></pre></div>
<p>Foo will be ordered exactly the same way as
<code class="sourceCode default">SomeType&lt;T&gt;</code></p>
<h2 data-number="5.3" id="lambda-types"><span class="header-section-number">5.3</span> Lambda Types<a href="#lambda-types" class="self-link"></a></h2>
<p>Lambda Types will be ordered in the namespace in which they are
declared. Ties are broken by the point of instantiation.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Banana <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">auto</span> i <span class="op">=</span> <span class="op">[](){}</span>;</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Apple <span class="op">{</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> i <span class="op">=</span> <span class="op">[](){}</span>;</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> j <span class="op">=</span> <span class="op">[](){}</span>;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>would be ordered:</p>
<p><code class="sourceCode default">decltype(Apple::i)</code> &lt;
<code class="sourceCode default">decltype(Apple::j)</code> &lt;
<code class="sourceCode default">decltype(Banana::i)</code></p>
<h2 data-number="5.4" id="concepts"><span class="header-section-number">5.4</span> Concepts<a href="#concepts" class="self-link"></a></h2>
<p>Concepts do not need to be ordered, since they are not types, only
restrict what types can be.</p>
<h2 data-number="5.5" id="parameter-packs"><span class="header-section-number">5.5</span> Parameter Packs<a href="#parameter-packs" class="self-link"></a></h2>
<p>Parameter packs are ordered by size first, then types compared left
to right.</p>
<p>Given:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Types<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Tuple <span class="op">{}</span>;</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo <span class="op">{}</span>;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bar <span class="op">{}</span>;</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;&gt;</span> t0;</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> t1;</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span>Foo<span class="op">&gt;</span> t2;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span>Bar<span class="op">&gt;</span> t3;</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span>Foo, Bar<span class="op">&gt;</span> t4;</span></code></pre></div>
<p>would be ordered:
<code class="sourceCode default">Tuple&lt;&gt;</code> &lt;
<code class="sourceCode default">Tuple&lt;int&gt;</code> &lt;
<code class="sourceCode default">Tuple&lt;Bar&gt;</code> &lt;
<code class="sourceCode default">Tuple&lt;Foo&gt;</code> &lt;
<code class="sourceCode default">Tuple&lt;Foo, Bar&gt;</code></p>
<h2 data-number="5.6" id="kinds-of-templates"><span class="header-section-number">5.6</span> Kinds of Templates<a href="#kinds-of-templates" class="self-link"></a></h2>
<p>Kinds of templates shall first be ordered by arity.</p>
<p>Given:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">class</span><span class="op">&gt;</span> <span class="kw">class</span> Template<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> two_arity<span class="op">{}</span>;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">class</span><span class="op">&gt;</span> <span class="kw">struct</span> one_arity<span class="op">{}</span>;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">struct</span> zero_arity<span class="op">{}</span>;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>zero_arity<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> value0;</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>one_arity<span class="op">&lt;</span>zero_arity<span class="op">&gt;</span> value1;</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>two_arity<span class="op">&lt;</span>one_arity<span class="op">&gt;</span> value2;</span></code></pre></div>
<p>shall be ordered <code class="sourceCode default">decltype(value0) &lt; decltype(value1) &lt; decltype(value2)</code>.</p>
<p>If two types have the same arity, they will be ordered based on
name.</p>
<p>Given:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">class</span><span class="op">&gt;</span> <span class="kw">class</span> Template<span class="op">&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> two_arityA<span class="op">{}</span>;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">class</span><span class="op">&gt;</span> <span class="kw">class</span> Template<span class="op">&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> two_arityB<span class="op">{}</span>;</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">class</span><span class="op">&gt;</span> <span class="kw">struct</span> one_arityA<span class="op">{}</span>;</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">class</span><span class="op">&gt;</span> <span class="kw">struct</span> one_arityB<span class="op">{}</span>;</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>two_arityA<span class="op">&lt;</span>one_arityA<span class="op">&gt;</span> value1;</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>two_arityA<span class="op">&lt;</span>one_arityB<span class="op">&gt;</span> value2;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>two_arityB<span class="op">&lt;</span>one_arityA<span class="op">&gt;</span> value3;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>two_arityB<span class="op">&lt;</span>one_arityB<span class="op">&gt;</span> value4;</span></code></pre></div>
<p>would be ordered <code class="sourceCode default">decltype(value1) &lt; decltype(value2) &lt; decltype(value3) &lt; decltype(value1)</code>,
as <code class="sourceCode default">two_arityA</code> comes before
<code class="sourceCode default">two_arityB</code> and
<code class="sourceCode default">one_arityA</code> comes before
<code class="sourceCode default">one_arityB</code>.</p>

\end{document}
